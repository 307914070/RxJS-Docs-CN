{
  "type": "Program",
  "body": [
    {
      "type": "ImportDeclaration",
      "specifiers": [
        {
          "type": "ImportSpecifier",
          "local": {
            "type": "Identifier",
            "name": "Observable",
            "range": [
              9,
              19
            ],
            "loc": {
              "start": {
                "line": 1,
                "column": 9
              },
              "end": {
                "line": 1,
                "column": 19
              }
            }
          },
          "imported": {
            "type": "Identifier",
            "name": "Observable",
            "range": [
              9,
              19
            ],
            "loc": {
              "start": {
                "line": 1,
                "column": 9
              },
              "end": {
                "line": 1,
                "column": 19
              }
            }
          },
          "range": [
            9,
            19
          ],
          "loc": {
            "start": {
              "line": 1,
              "column": 9
            },
            "end": {
              "line": 1,
              "column": 19
            }
          }
        }
      ],
      "source": {
        "type": "Literal",
        "value": "./Observable",
        "raw": "'./Observable'",
        "range": [
          27,
          41
        ],
        "loc": {
          "start": {
            "line": 1,
            "column": 27
          },
          "end": {
            "line": 1,
            "column": 41
          }
        }
      },
      "range": [
        0,
        42
      ],
      "loc": {
        "start": {
          "line": 1,
          "column": 0
        },
        "end": {
          "line": 1,
          "column": 42
        }
      }
    },
    {
      "type": "ImportDeclaration",
      "specifiers": [],
      "source": {
        "type": "Literal",
        "value": "./observable/dom/MiscJSDoc",
        "raw": "'./observable/dom/MiscJSDoc'",
        "range": [
          50,
          78
        ],
        "loc": {
          "start": {
            "line": 2,
            "column": 7
          },
          "end": {
            "line": 2,
            "column": 35
          }
        }
      },
      "range": [
        43,
        79
      ],
      "loc": {
        "start": {
          "line": 2,
          "column": 0
        },
        "end": {
          "line": 2,
          "column": 36
        }
      },
      "trailingComments": [
        {
          "type": "Block",
          "value": "*\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n ",
          "range": [
            80,
            174
          ],
          "loc": {
            "start": {
              "line": 3,
              "column": 0
            },
            "end": {
              "line": 7,
              "column": 3
            }
          }
        }
      ]
    },
    {
      "type": "ExportNamedDeclaration",
      "declaration": {
        "type": "ClassDeclaration",
        "id": {
          "type": "Identifier",
          "name": "ObservableDoc",
          "range": [
            188,
            201
          ],
          "loc": {
            "start": {
              "line": 8,
              "column": 13
            },
            "end": {
              "line": 8,
              "column": 26
            }
          }
        },
        "superClass": null,
        "body": {
          "type": "ClassBody",
          "body": [
            {
              "type": "MethodDefinition",
              "key": {
                "type": "Identifier",
                "name": "create",
                "range": [
                  5465,
                  5471
                ],
                "loc": {
                  "start": {
                    "line": 128,
                    "column": 11
                  },
                  "end": {
                    "line": 128,
                    "column": 17
                  }
                }
              },
              "value": {
                "type": "FunctionExpression",
                "id": null,
                "params": [
                  {
                    "type": "Identifier",
                    "name": "onSubscription",
                    "range": [
                      5472,
                      5486
                    ],
                    "loc": {
                      "start": {
                        "line": 128,
                        "column": 18
                      },
                      "end": {
                        "line": 128,
                        "column": 32
                      }
                    }
                  }
                ],
                "body": {
                  "type": "BlockStatement",
                  "body": [
                    {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "NewExpression",
                        "callee": {
                          "type": "Identifier",
                          "name": "Observable",
                          "range": [
                            5509,
                            5519
                          ],
                          "loc": {
                            "start": {
                              "line": 129,
                              "column": 19
                            },
                            "end": {
                              "line": 129,
                              "column": 29
                            }
                          }
                        },
                        "arguments": [
                          {
                            "type": "Identifier",
                            "name": "onSubscription",
                            "range": [
                              5520,
                              5534
                            ],
                            "loc": {
                              "start": {
                                "line": 129,
                                "column": 30
                              },
                              "end": {
                                "line": 129,
                                "column": 44
                              }
                            }
                          }
                        ],
                        "range": [
                          5505,
                          5535
                        ],
                        "loc": {
                          "start": {
                            "line": 129,
                            "column": 15
                          },
                          "end": {
                            "line": 129,
                            "column": 45
                          }
                        }
                      },
                      "range": [
                        5498,
                        5536
                      ],
                      "loc": {
                        "start": {
                          "line": 129,
                          "column": 8
                        },
                        "end": {
                          "line": 129,
                          "column": 46
                        }
                      }
                    }
                  ],
                  "range": [
                    5488,
                    5542
                  ],
                  "loc": {
                    "start": {
                      "line": 128,
                      "column": 34
                    },
                    "end": {
                      "line": 130,
                      "column": 5
                    }
                  }
                },
                "generator": false,
                "expression": false,
                "range": [
                  5471,
                  5542
                ],
                "loc": {
                  "start": {
                    "line": 128,
                    "column": 17
                  },
                  "end": {
                    "line": 130,
                    "column": 5
                  }
                }
              },
              "kind": "method",
              "computed": false,
              "range": [
                5458,
                5542
              ],
              "loc": {
                "start": {
                  "line": 128,
                  "column": 4
                },
                "end": {
                  "line": 130,
                  "column": 5
                }
              },
              "leadingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * Creates a new Observable, that will execute the specified function when an\n     * {@link Observer} subscribes to it.\n     *\n     * <span class=\"informal\">Create custom Observable, that does whatever you like.</span>\n     *\n     * <img src=\"./img/create.png\" width=\"100%\">\n     *\n     * `create` converts an `onSubscription` function to an actual Observable.\n     * Whenever someone subscribes to that Observable, the function will be called\n     * with an {@link Observer} instance as a first and only parameter. `onSubscription` should\n     * then invoke the Observers `next`, `error` and `complete` methods.\n     *\n     * Calling `next` with a value will emit that value to the observer. Calling `complete`\n     * means that Observable finished emitting and will not do anything else.\n     * Calling `error` means that something went wrong - value passed to `error` method should\n     * provide details on what exactly happened.\n     *\n     * A well-formed Observable can emit as many values as it needs via `next` method,\n     * but `complete` and `error` methods can be called only once and nothing else can be called\n     * thereafter. If you try to invoke `next`, `complete` or `error` methods after created\n     * Observable already completed or ended with an error, these calls will be ignored to\n     * preserve so called *Observable Contract*. Note that you are not required to call\n     * `complete` at any point - it is perfectly fine to create an Observable that never ends,\n     * depending on your needs.\n     *\n     * `onSubscription` can optionally return either a function or an object with\n     * `unsubscribe` method. In both cases function or method will be called when\n     * subscription to Observable is being cancelled and should be used to clean up all\n     * resources. So, for example, if you are using `setTimeout` in your custom\n     * Observable, when someone unsubscribes, you can clear planned timeout, so that\n     * it does not fire needlessly and browser (or other environment) does not waste\n     * computing power on timing event that no one will listen to anyways.\n     *\n     * Most of the times you should not need to use `create`, because existing\n     * operators allow you to create an Observable for most of the use cases.\n     * That being said, `create` is low-level mechanism allowing you to create\n     * any Observable, if you have very specific needs.\n     *\n     * **TypeScript signature issue**\n     *\n     * Because Observable extends class which already has defined static `create` function,\n     * but with different type signature, it was impossible to assign proper signature to\n     * `Observable.create`. Because of that, it has very general type `Function` and thus\n     * function passed to `create` will not be type checked, unless you explicitly state\n     * what signature it should have.\n     *\n     * When using TypeScript we recommend to declare type signature of function passed to\n     * `create` as `(observer: Observer) => TeardownLogic`, where {@link Observer}\n     * and {@link TeardownLogic} are interfaces provided by the library.\n     *\n     * @example <caption>Emit three numbers, then complete.</caption>\n     * var observable = Rx.Observable.create(function (observer) {\n     *   observer.next(1);\n     *   observer.next(2);\n     *   observer.next(3);\n     *   observer.complete();\n     * });\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('this is the end')\n     * );\n     *\n     * // Logs\n     * // 1\n     * // 2\n     * // 3\n     * // \"this is the end\"\n     *\n     *\n     * @example <caption>Emit an error</caption>\n     * const observable = Rx.Observable.create((observer) => {\n     *   observer.error('something went really wrong...');\n     * });\n     *\n     * observable.subscribe(\n     *   value => console.log(value), // will never be called\n     *   err => console.log(err),\n     *   () => console.log('complete') // will never be called\n     * );\n     *\n     * // Logs\n     * // \"something went really wrong...\"\n     *\n     *\n     * @example <caption>Return unsubscribe function</caption>\n     *\n     * const observable = Rx.Observable.create(observer => {\n     *   const id = setTimeout(() => observer.next('...'), 5000); // emit value after 5s\n     *\n     *   return () => { clearTimeout(id); console.log('cleared!'); };\n     * });\n     *\n     * const subscription = observable.subscribe(value => console.log(value));\n     *\n     * setTimeout(() => subscription.unsubscribe(), 3000); // cancel subscription after 3s\n     *\n     * // Logs:\n     * // \"cleared!\" after 3s\n     *\n     * // Never logs \"...\"\n     *\n     *\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {function(observer: Observer): TeardownLogic} onSubscription A\n     * function that accepts an Observer, and invokes its `next`,\n     * `error`, and `complete` methods as appropriate, and optionally returns some\n     * logic for cleaning up resources.\n     * @return {Observable} An Observable that, whenever subscribed, will execute the\n     * specified function.\n     * @static true\n     * @name create\n     * @owner Observable\n     ",
                  "range": [
                    208,
                    5453
                  ],
                  "loc": {
                    "start": {
                      "line": 9,
                      "column": 4
                    },
                    "end": {
                      "line": 127,
                      "column": 7
                    }
                  }
                }
              ],
              "static": true
            }
          ],
          "range": [
            202,
            5550
          ],
          "loc": {
            "start": {
              "line": 8,
              "column": 27
            },
            "end": {
              "line": 132,
              "column": 1
            }
          }
        },
        "range": [
          182,
          5550
        ],
        "loc": {
          "start": {
            "line": 8,
            "column": 7
          },
          "end": {
            "line": 132,
            "column": 1
          }
        },
        "leadingComments": [
          {
            "type": "Block",
            "value": "*\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n ",
            "range": [
              80,
              174
            ],
            "loc": {
              "start": {
                "line": 3,
                "column": 0
              },
              "end": {
                "line": 7,
                "column": 3
              }
            }
          }
        ],
        "trailingComments": [
          {
            "type": "Block",
            "value": "*\n * An interface for a consumer of push-based notifications delivered by an\n * {@link Observable}.\n *\n * ```ts\n * interface Observer<T> {\n *   closed?: boolean;\n *   next: (value: T) => void;\n *   error: (err: any) => void;\n *   complete: () => void;\n * }\n * ```\n *\n * An object conforming to the Observer interface is usually\n * given to the `observable.subscribe(observer)` method, and the Observable will\n * call the Observer's `next(value)` method to provide notifications. A\n * well-behaved Observable will call an Observer's `complete()` method exactly\n * once or the Observer's `error(err)` method exactly once, as the last\n * notification delivered.\n *\n * @interface\n * @name Observer\n * @noimport true\n ",
            "range": [
              5551,
              6268
            ],
            "loc": {
              "start": {
                "line": 133,
                "column": 0
              },
              "end": {
                "line": 156,
                "column": 3
              }
            }
          }
        ]
      },
      "specifiers": [],
      "source": null,
      "range": [
        175,
        5550
      ],
      "loc": {
        "start": {
          "line": 8,
          "column": 0
        },
        "end": {
          "line": 132,
          "column": 1
        }
      },
      "leadingComments": [
        {
          "type": "Block",
          "value": "*\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n ",
          "range": [
            80,
            174
          ],
          "loc": {
            "start": {
              "line": 3,
              "column": 0
            },
            "end": {
              "line": 7,
              "column": 3
            }
          }
        }
      ],
      "trailingComments": [
        {
          "type": "Block",
          "value": "*\n * An interface for a consumer of push-based notifications delivered by an\n * {@link Observable}.\n *\n * ```ts\n * interface Observer<T> {\n *   closed?: boolean;\n *   next: (value: T) => void;\n *   error: (err: any) => void;\n *   complete: () => void;\n * }\n * ```\n *\n * An object conforming to the Observer interface is usually\n * given to the `observable.subscribe(observer)` method, and the Observable will\n * call the Observer's `next(value)` method to provide notifications. A\n * well-behaved Observable will call an Observer's `complete()` method exactly\n * once or the Observer's `error(err)` method exactly once, as the last\n * notification delivered.\n *\n * @interface\n * @name Observer\n * @noimport true\n ",
          "range": [
            5551,
            6268
          ],
          "loc": {
            "start": {
              "line": 133,
              "column": 0
            },
            "end": {
              "line": 156,
              "column": 3
            }
          }
        }
      ]
    },
    {
      "type": "ExportNamedDeclaration",
      "declaration": {
        "type": "ClassDeclaration",
        "id": {
          "type": "Identifier",
          "name": "ObserverDoc",
          "range": [
            6282,
            6293
          ],
          "loc": {
            "start": {
              "line": 157,
              "column": 13
            },
            "end": {
              "line": 157,
              "column": 24
            }
          }
        },
        "superClass": null,
        "body": {
          "type": "ClassBody",
          "body": [
            {
              "type": "MethodDefinition",
              "key": {
                "type": "Identifier",
                "name": "constructor",
                "range": [
                  6300,
                  6311
                ],
                "loc": {
                  "start": {
                    "line": 158,
                    "column": 4
                  },
                  "end": {
                    "line": 158,
                    "column": 15
                  }
                }
              },
              "value": {
                "type": "FunctionExpression",
                "id": null,
                "params": [],
                "body": {
                  "type": "BlockStatement",
                  "body": [
                    {
                      "type": "ExpressionStatement",
                      "expression": {
                        "type": "AssignmentExpression",
                        "operator": "=",
                        "left": {
                          "type": "MemberExpression",
                          "computed": false,
                          "object": {
                            "type": "ThisExpression",
                            "range": [
                              6527,
                              6531
                            ],
                            "loc": {
                              "start": {
                                "line": 164,
                                "column": 8
                              },
                              "end": {
                                "line": 164,
                                "column": 12
                              }
                            }
                          },
                          "property": {
                            "type": "Identifier",
                            "name": "closed",
                            "range": [
                              6532,
                              6538
                            ],
                            "loc": {
                              "start": {
                                "line": 164,
                                "column": 13
                              },
                              "end": {
                                "line": 164,
                                "column": 19
                              }
                            }
                          },
                          "range": [
                            6527,
                            6538
                          ],
                          "loc": {
                            "start": {
                              "line": 164,
                              "column": 8
                            },
                            "end": {
                              "line": 164,
                              "column": 19
                            }
                          }
                        },
                        "right": {
                          "type": "Literal",
                          "value": false,
                          "raw": "false",
                          "range": [
                            6541,
                            6546
                          ],
                          "loc": {
                            "start": {
                              "line": 164,
                              "column": 22
                            },
                            "end": {
                              "line": 164,
                              "column": 27
                            }
                          }
                        },
                        "range": [
                          6527,
                          6546
                        ],
                        "loc": {
                          "start": {
                            "line": 164,
                            "column": 8
                          },
                          "end": {
                            "line": 164,
                            "column": 27
                          }
                        }
                      },
                      "range": [
                        6527,
                        6547
                      ],
                      "loc": {
                        "start": {
                          "line": 164,
                          "column": 8
                        },
                        "end": {
                          "line": 164,
                          "column": 28
                        }
                      },
                      "leadingComments": [
                        {
                          "type": "Block",
                          "value": "*\n         * An optional flag to indicate whether this Observer, when used as a\n         * subscriber, has already been unsubscribed from its Observable.\n         * @type {boolean}\n         ",
                          "range": [
                            6324,
                            6518
                          ],
                          "loc": {
                            "start": {
                              "line": 159,
                              "column": 8
                            },
                            "end": {
                              "line": 163,
                              "column": 11
                            }
                          }
                        }
                      ]
                    }
                  ],
                  "range": [
                    6314,
                    6553
                  ],
                  "loc": {
                    "start": {
                      "line": 158,
                      "column": 18
                    },
                    "end": {
                      "line": 165,
                      "column": 5
                    }
                  }
                },
                "generator": false,
                "expression": false,
                "range": [
                  6311,
                  6553
                ],
                "loc": {
                  "start": {
                    "line": 158,
                    "column": 15
                  },
                  "end": {
                    "line": 165,
                    "column": 5
                  }
                }
              },
              "kind": "constructor",
              "computed": false,
              "range": [
                6300,
                6553
              ],
              "loc": {
                "start": {
                  "line": 158,
                  "column": 4
                },
                "end": {
                  "line": 165,
                  "column": 5
                }
              },
              "trailingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive notifications of type `next` from the Observable,\n     * with a value. The Observable may call this method 0 or more times.\n     * @param {T} value The `next` value.\n     * @return {void}\n     ",
                  "range": [
                    6558,
                    6788
                  ],
                  "loc": {
                    "start": {
                      "line": 166,
                      "column": 4
                    },
                    "end": {
                      "line": 171,
                      "column": 7
                    }
                  }
                }
              ],
              "static": false
            },
            {
              "type": "MethodDefinition",
              "key": {
                "type": "Identifier",
                "name": "next",
                "range": [
                  6793,
                  6797
                ],
                "loc": {
                  "start": {
                    "line": 172,
                    "column": 4
                  },
                  "end": {
                    "line": 172,
                    "column": 8
                  }
                }
              },
              "value": {
                "type": "FunctionExpression",
                "id": null,
                "params": [
                  {
                    "type": "Identifier",
                    "name": "value",
                    "range": [
                      6798,
                      6803
                    ],
                    "loc": {
                      "start": {
                        "line": 172,
                        "column": 9
                      },
                      "end": {
                        "line": 172,
                        "column": 14
                      }
                    }
                  }
                ],
                "body": {
                  "type": "BlockStatement",
                  "body": [
                    {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "UnaryExpression",
                        "operator": "void",
                        "argument": {
                          "type": "Literal",
                          "value": 0,
                          "raw": "0",
                          "range": [
                            6827,
                            6828
                          ],
                          "loc": {
                            "start": {
                              "line": 173,
                              "column": 20
                            },
                            "end": {
                              "line": 173,
                              "column": 21
                            }
                          }
                        },
                        "prefix": true,
                        "range": [
                          6822,
                          6828
                        ],
                        "loc": {
                          "start": {
                            "line": 173,
                            "column": 15
                          },
                          "end": {
                            "line": 173,
                            "column": 21
                          }
                        }
                      },
                      "range": [
                        6815,
                        6829
                      ],
                      "loc": {
                        "start": {
                          "line": 173,
                          "column": 8
                        },
                        "end": {
                          "line": 173,
                          "column": 22
                        }
                      }
                    }
                  ],
                  "range": [
                    6805,
                    6835
                  ],
                  "loc": {
                    "start": {
                      "line": 172,
                      "column": 16
                    },
                    "end": {
                      "line": 174,
                      "column": 5
                    }
                  }
                },
                "generator": false,
                "expression": false,
                "range": [
                  6797,
                  6835
                ],
                "loc": {
                  "start": {
                    "line": 172,
                    "column": 8
                  },
                  "end": {
                    "line": 174,
                    "column": 5
                  }
                }
              },
              "kind": "method",
              "computed": false,
              "range": [
                6793,
                6835
              ],
              "loc": {
                "start": {
                  "line": 172,
                  "column": 4
                },
                "end": {
                  "line": 174,
                  "column": 5
                }
              },
              "leadingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive notifications of type `next` from the Observable,\n     * with a value. The Observable may call this method 0 or more times.\n     * @param {T} value The `next` value.\n     * @return {void}\n     ",
                  "range": [
                    6558,
                    6788
                  ],
                  "loc": {
                    "start": {
                      "line": 166,
                      "column": 4
                    },
                    "end": {
                      "line": 171,
                      "column": 7
                    }
                  }
                }
              ],
              "trailingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive notifications of type `error` from the Observable,\n     * with an attached {@link Error}. Notifies the Observer that the Observable\n     * has experienced an error condition.\n     * @param {any} err The `error` exception.\n     * @return {void}\n     ",
                  "range": [
                    6840,
                    7126
                  ],
                  "loc": {
                    "start": {
                      "line": 175,
                      "column": 4
                    },
                    "end": {
                      "line": 181,
                      "column": 7
                    }
                  }
                }
              ],
              "static": false
            },
            {
              "type": "MethodDefinition",
              "key": {
                "type": "Identifier",
                "name": "error",
                "range": [
                  7131,
                  7136
                ],
                "loc": {
                  "start": {
                    "line": 182,
                    "column": 4
                  },
                  "end": {
                    "line": 182,
                    "column": 9
                  }
                }
              },
              "value": {
                "type": "FunctionExpression",
                "id": null,
                "params": [
                  {
                    "type": "Identifier",
                    "name": "err",
                    "range": [
                      7137,
                      7140
                    ],
                    "loc": {
                      "start": {
                        "line": 182,
                        "column": 10
                      },
                      "end": {
                        "line": 182,
                        "column": 13
                      }
                    }
                  }
                ],
                "body": {
                  "type": "BlockStatement",
                  "body": [
                    {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "UnaryExpression",
                        "operator": "void",
                        "argument": {
                          "type": "Literal",
                          "value": 0,
                          "raw": "0",
                          "range": [
                            7164,
                            7165
                          ],
                          "loc": {
                            "start": {
                              "line": 183,
                              "column": 20
                            },
                            "end": {
                              "line": 183,
                              "column": 21
                            }
                          }
                        },
                        "prefix": true,
                        "range": [
                          7159,
                          7165
                        ],
                        "loc": {
                          "start": {
                            "line": 183,
                            "column": 15
                          },
                          "end": {
                            "line": 183,
                            "column": 21
                          }
                        }
                      },
                      "range": [
                        7152,
                        7166
                      ],
                      "loc": {
                        "start": {
                          "line": 183,
                          "column": 8
                        },
                        "end": {
                          "line": 183,
                          "column": 22
                        }
                      }
                    }
                  ],
                  "range": [
                    7142,
                    7172
                  ],
                  "loc": {
                    "start": {
                      "line": 182,
                      "column": 15
                    },
                    "end": {
                      "line": 184,
                      "column": 5
                    }
                  }
                },
                "generator": false,
                "expression": false,
                "range": [
                  7136,
                  7172
                ],
                "loc": {
                  "start": {
                    "line": 182,
                    "column": 9
                  },
                  "end": {
                    "line": 184,
                    "column": 5
                  }
                }
              },
              "kind": "method",
              "computed": false,
              "range": [
                7131,
                7172
              ],
              "loc": {
                "start": {
                  "line": 182,
                  "column": 4
                },
                "end": {
                  "line": 184,
                  "column": 5
                }
              },
              "leadingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive notifications of type `error` from the Observable,\n     * with an attached {@link Error}. Notifies the Observer that the Observable\n     * has experienced an error condition.\n     * @param {any} err The `error` exception.\n     * @return {void}\n     ",
                  "range": [
                    6840,
                    7126
                  ],
                  "loc": {
                    "start": {
                      "line": 175,
                      "column": 4
                    },
                    "end": {
                      "line": 181,
                      "column": 7
                    }
                  }
                }
              ],
              "trailingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive a valueless notification of type `complete` from\n     * the Observable. Notifies the Observer that the Observable has finished\n     * sending push-based notifications.\n     * @return {void}\n     ",
                  "range": [
                    7177,
                    7409
                  ],
                  "loc": {
                    "start": {
                      "line": 185,
                      "column": 4
                    },
                    "end": {
                      "line": 190,
                      "column": 7
                    }
                  }
                }
              ],
              "static": false
            },
            {
              "type": "MethodDefinition",
              "key": {
                "type": "Identifier",
                "name": "complete",
                "range": [
                  7414,
                  7422
                ],
                "loc": {
                  "start": {
                    "line": 191,
                    "column": 4
                  },
                  "end": {
                    "line": 191,
                    "column": 12
                  }
                }
              },
              "value": {
                "type": "FunctionExpression",
                "id": null,
                "params": [],
                "body": {
                  "type": "BlockStatement",
                  "body": [
                    {
                      "type": "ReturnStatement",
                      "argument": {
                        "type": "UnaryExpression",
                        "operator": "void",
                        "argument": {
                          "type": "Literal",
                          "value": 0,
                          "raw": "0",
                          "range": [
                            7447,
                            7448
                          ],
                          "loc": {
                            "start": {
                              "line": 192,
                              "column": 20
                            },
                            "end": {
                              "line": 192,
                              "column": 21
                            }
                          }
                        },
                        "prefix": true,
                        "range": [
                          7442,
                          7448
                        ],
                        "loc": {
                          "start": {
                            "line": 192,
                            "column": 15
                          },
                          "end": {
                            "line": 192,
                            "column": 21
                          }
                        }
                      },
                      "range": [
                        7435,
                        7449
                      ],
                      "loc": {
                        "start": {
                          "line": 192,
                          "column": 8
                        },
                        "end": {
                          "line": 192,
                          "column": 22
                        }
                      }
                    }
                  ],
                  "range": [
                    7425,
                    7455
                  ],
                  "loc": {
                    "start": {
                      "line": 191,
                      "column": 15
                    },
                    "end": {
                      "line": 193,
                      "column": 5
                    }
                  }
                },
                "generator": false,
                "expression": false,
                "range": [
                  7422,
                  7455
                ],
                "loc": {
                  "start": {
                    "line": 191,
                    "column": 12
                  },
                  "end": {
                    "line": 193,
                    "column": 5
                  }
                }
              },
              "kind": "method",
              "computed": false,
              "range": [
                7414,
                7455
              ],
              "loc": {
                "start": {
                  "line": 191,
                  "column": 4
                },
                "end": {
                  "line": 193,
                  "column": 5
                }
              },
              "leadingComments": [
                {
                  "type": "Block",
                  "value": "*\n     * The callback to receive a valueless notification of type `complete` from\n     * the Observable. Notifies the Observer that the Observable has finished\n     * sending push-based notifications.\n     * @return {void}\n     ",
                  "range": [
                    7177,
                    7409
                  ],
                  "loc": {
                    "start": {
                      "line": 185,
                      "column": 4
                    },
                    "end": {
                      "line": 190,
                      "column": 7
                    }
                  }
                }
              ],
              "static": false
            }
          ],
          "range": [
            6294,
            7457
          ],
          "loc": {
            "start": {
              "line": 157,
              "column": 25
            },
            "end": {
              "line": 194,
              "column": 1
            }
          }
        },
        "range": [
          6276,
          7457
        ],
        "loc": {
          "start": {
            "line": 157,
            "column": 7
          },
          "end": {
            "line": 194,
            "column": 1
          }
        },
        "leadingComments": [
          {
            "type": "Block",
            "value": "*\n * An interface for a consumer of push-based notifications delivered by an\n * {@link Observable}.\n *\n * ```ts\n * interface Observer<T> {\n *   closed?: boolean;\n *   next: (value: T) => void;\n *   error: (err: any) => void;\n *   complete: () => void;\n * }\n * ```\n *\n * An object conforming to the Observer interface is usually\n * given to the `observable.subscribe(observer)` method, and the Observable will\n * call the Observer's `next(value)` method to provide notifications. A\n * well-behaved Observable will call an Observer's `complete()` method exactly\n * once or the Observer's `error(err)` method exactly once, as the last\n * notification delivered.\n *\n * @interface\n * @name Observer\n * @noimport true\n ",
            "range": [
              5551,
              6268
            ],
            "loc": {
              "start": {
                "line": 133,
                "column": 0
              },
              "end": {
                "line": 156,
                "column": 3
              }
            }
          }
        ],
        "trailingComments": [
          {
            "type": "Block",
            "value": "*\n * `SubscribableOrPromise` interface describes values that behave like either\n * Observables or Promises. Every operator that accepts arguments annotated\n * with this interface, can be also used with parameters that are not necessarily\n * RxJS Observables.\n *\n * Following types of values might be passed to operators expecting this interface:\n *\n * ## Observable\n *\n * RxJS {@link Observable} instance.\n *\n * ## Observable-like (Subscribable)\n *\n * This might be any object that has `Symbol.observable` method. This method,\n * when called, should return object with `subscribe` method on it, which should\n * behave the same as RxJS `Observable.subscribe`.\n *\n * `Symbol.observable` is part of https://github.com/tc39/proposal-observable proposal.\n * Since currently it is not supported natively, and every symbol is equal only to itself,\n * you should use https://github.com/blesh/symbol-observable polyfill, when implementing\n * custom Observable-likes.\n *\n * **TypeScript Subscribable interface issue**\n *\n * Although TypeScript interface claims that Subscribable is an object that has `subscribe`\n * method declared directly on it, passing custom objects that have `subscribe`\n * method but not `Symbol.observable` method will fail at runtime. Conversely, passing\n * objects with `Symbol.observable` but without `subscribe` will fail at compile time\n * (if you use TypeScript).\n *\n * TypeScript has problem supporting interfaces with methods defined as symbol\n * properties. To get around that, you should implement `subscribe` directly on\n * passed object, and make `Symbol.observable` method simply return `this`. That way\n * everything will work as expected, and compiler will not complain. If you really\n * do not want to put `subscribe` directly on your object, you will have to type cast\n * it to `any`, before passing it to an operator.\n *\n * When this issue is resolved, Subscribable interface will only permit Observable-like\n * objects with `Symbol.observable` defined, no matter if they themselves implement\n * `subscribe` method or not.\n *\n * ## ES6 Promise\n *\n * Promise can be interpreted as Observable that emits value and completes\n * when it is resolved or errors when it is rejected.\n *\n * ## Promise-like (Thenable)\n *\n * Promises passed to operators do not have to be native ES6 Promises.\n * They can be implementations from popular Promise libraries, polyfills\n * or even custom ones. They just need to have `then` method that works\n * as the same as ES6 Promise `then`.\n *\n * @example <caption>Use merge and then map with non-RxJS observable</caption>\n * const nonRxJSObservable = {\n *   subscribe(observer) {\n *     observer.next(1000);\n *     observer.complete();\n *   },\n *   [Symbol.observable]() {\n *     return this;\n *   }\n * };\n *\n * Rx.Observable.merge(nonRxJSObservable)\n * .map(value => \"This value is \" + value)\n * .subscribe(result => console.log(result)); // Logs \"This value is 1000\"\n *\n *\n * @example <caption>Use combineLatest with ES6 Promise</caption>\n * Rx.Observable.combineLatest(Promise.resolve(5), Promise.resolve(10), Promise.resolve(15))\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n * // Logs\n * // [5, 10, 15]\n * // \"the end!\"\n *\n *\n * @interface\n * @name SubscribableOrPromise\n * @noimport true\n ",
            "range": [
              7458,
              10776
            ],
            "loc": {
              "start": {
                "line": 195,
                "column": 0
              },
              "end": {
                "line": 280,
                "column": 3
              }
            }
          }
        ]
      },
      "specifiers": [],
      "source": null,
      "range": [
        6269,
        7457
      ],
      "loc": {
        "start": {
          "line": 157,
          "column": 0
        },
        "end": {
          "line": 194,
          "column": 1
        }
      },
      "leadingComments": [
        {
          "type": "Block",
          "value": "*\n * An interface for a consumer of push-based notifications delivered by an\n * {@link Observable}.\n *\n * ```ts\n * interface Observer<T> {\n *   closed?: boolean;\n *   next: (value: T) => void;\n *   error: (err: any) => void;\n *   complete: () => void;\n * }\n * ```\n *\n * An object conforming to the Observer interface is usually\n * given to the `observable.subscribe(observer)` method, and the Observable will\n * call the Observer's `next(value)` method to provide notifications. A\n * well-behaved Observable will call an Observer's `complete()` method exactly\n * once or the Observer's `error(err)` method exactly once, as the last\n * notification delivered.\n *\n * @interface\n * @name Observer\n * @noimport true\n ",
          "range": [
            5551,
            6268
          ],
          "loc": {
            "start": {
              "line": 133,
              "column": 0
            },
            "end": {
              "line": 156,
              "column": 3
            }
          }
        }
      ],
      "trailingComments": [
        {
          "type": "Block",
          "value": "*\n * `SubscribableOrPromise` interface describes values that behave like either\n * Observables or Promises. Every operator that accepts arguments annotated\n * with this interface, can be also used with parameters that are not necessarily\n * RxJS Observables.\n *\n * Following types of values might be passed to operators expecting this interface:\n *\n * ## Observable\n *\n * RxJS {@link Observable} instance.\n *\n * ## Observable-like (Subscribable)\n *\n * This might be any object that has `Symbol.observable` method. This method,\n * when called, should return object with `subscribe` method on it, which should\n * behave the same as RxJS `Observable.subscribe`.\n *\n * `Symbol.observable` is part of https://github.com/tc39/proposal-observable proposal.\n * Since currently it is not supported natively, and every symbol is equal only to itself,\n * you should use https://github.com/blesh/symbol-observable polyfill, when implementing\n * custom Observable-likes.\n *\n * **TypeScript Subscribable interface issue**\n *\n * Although TypeScript interface claims that Subscribable is an object that has `subscribe`\n * method declared directly on it, passing custom objects that have `subscribe`\n * method but not `Symbol.observable` method will fail at runtime. Conversely, passing\n * objects with `Symbol.observable` but without `subscribe` will fail at compile time\n * (if you use TypeScript).\n *\n * TypeScript has problem supporting interfaces with methods defined as symbol\n * properties. To get around that, you should implement `subscribe` directly on\n * passed object, and make `Symbol.observable` method simply return `this`. That way\n * everything will work as expected, and compiler will not complain. If you really\n * do not want to put `subscribe` directly on your object, you will have to type cast\n * it to `any`, before passing it to an operator.\n *\n * When this issue is resolved, Subscribable interface will only permit Observable-like\n * objects with `Symbol.observable` defined, no matter if they themselves implement\n * `subscribe` method or not.\n *\n * ## ES6 Promise\n *\n * Promise can be interpreted as Observable that emits value and completes\n * when it is resolved or errors when it is rejected.\n *\n * ## Promise-like (Thenable)\n *\n * Promises passed to operators do not have to be native ES6 Promises.\n * They can be implementations from popular Promise libraries, polyfills\n * or even custom ones. They just need to have `then` method that works\n * as the same as ES6 Promise `then`.\n *\n * @example <caption>Use merge and then map with non-RxJS observable</caption>\n * const nonRxJSObservable = {\n *   subscribe(observer) {\n *     observer.next(1000);\n *     observer.complete();\n *   },\n *   [Symbol.observable]() {\n *     return this;\n *   }\n * };\n *\n * Rx.Observable.merge(nonRxJSObservable)\n * .map(value => \"This value is \" + value)\n * .subscribe(result => console.log(result)); // Logs \"This value is 1000\"\n *\n *\n * @example <caption>Use combineLatest with ES6 Promise</caption>\n * Rx.Observable.combineLatest(Promise.resolve(5), Promise.resolve(10), Promise.resolve(15))\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n * // Logs\n * // [5, 10, 15]\n * // \"the end!\"\n *\n *\n * @interface\n * @name SubscribableOrPromise\n * @noimport true\n ",
          "range": [
            7458,
            10776
          ],
          "loc": {
            "start": {
              "line": 195,
              "column": 0
            },
            "end": {
              "line": 280,
              "column": 3
            }
          }
        }
      ]
    },
    {
      "type": "ExportNamedDeclaration",
      "declaration": {
        "type": "ClassDeclaration",
        "id": {
          "type": "Identifier",
          "name": "SubscribableOrPromiseDoc",
          "range": [
            10790,
            10814
          ],
          "loc": {
            "start": {
              "line": 281,
              "column": 13
            },
            "end": {
              "line": 281,
              "column": 37
            }
          }
        },
        "superClass": null,
        "body": {
          "type": "ClassBody",
          "body": [],
          "range": [
            10815,
            10818
          ],
          "loc": {
            "start": {
              "line": 281,
              "column": 38
            },
            "end": {
              "line": 282,
              "column": 1
            }
          }
        },
        "range": [
          10784,
          10818
        ],
        "loc": {
          "start": {
            "line": 281,
            "column": 7
          },
          "end": {
            "line": 282,
            "column": 1
          }
        },
        "leadingComments": [
          {
            "type": "Block",
            "value": "*\n * `SubscribableOrPromise` interface describes values that behave like either\n * Observables or Promises. Every operator that accepts arguments annotated\n * with this interface, can be also used with parameters that are not necessarily\n * RxJS Observables.\n *\n * Following types of values might be passed to operators expecting this interface:\n *\n * ## Observable\n *\n * RxJS {@link Observable} instance.\n *\n * ## Observable-like (Subscribable)\n *\n * This might be any object that has `Symbol.observable` method. This method,\n * when called, should return object with `subscribe` method on it, which should\n * behave the same as RxJS `Observable.subscribe`.\n *\n * `Symbol.observable` is part of https://github.com/tc39/proposal-observable proposal.\n * Since currently it is not supported natively, and every symbol is equal only to itself,\n * you should use https://github.com/blesh/symbol-observable polyfill, when implementing\n * custom Observable-likes.\n *\n * **TypeScript Subscribable interface issue**\n *\n * Although TypeScript interface claims that Subscribable is an object that has `subscribe`\n * method declared directly on it, passing custom objects that have `subscribe`\n * method but not `Symbol.observable` method will fail at runtime. Conversely, passing\n * objects with `Symbol.observable` but without `subscribe` will fail at compile time\n * (if you use TypeScript).\n *\n * TypeScript has problem supporting interfaces with methods defined as symbol\n * properties. To get around that, you should implement `subscribe` directly on\n * passed object, and make `Symbol.observable` method simply return `this`. That way\n * everything will work as expected, and compiler will not complain. If you really\n * do not want to put `subscribe` directly on your object, you will have to type cast\n * it to `any`, before passing it to an operator.\n *\n * When this issue is resolved, Subscribable interface will only permit Observable-like\n * objects with `Symbol.observable` defined, no matter if they themselves implement\n * `subscribe` method or not.\n *\n * ## ES6 Promise\n *\n * Promise can be interpreted as Observable that emits value and completes\n * when it is resolved or errors when it is rejected.\n *\n * ## Promise-like (Thenable)\n *\n * Promises passed to operators do not have to be native ES6 Promises.\n * They can be implementations from popular Promise libraries, polyfills\n * or even custom ones. They just need to have `then` method that works\n * as the same as ES6 Promise `then`.\n *\n * @example <caption>Use merge and then map with non-RxJS observable</caption>\n * const nonRxJSObservable = {\n *   subscribe(observer) {\n *     observer.next(1000);\n *     observer.complete();\n *   },\n *   [Symbol.observable]() {\n *     return this;\n *   }\n * };\n *\n * Rx.Observable.merge(nonRxJSObservable)\n * .map(value => \"This value is \" + value)\n * .subscribe(result => console.log(result)); // Logs \"This value is 1000\"\n *\n *\n * @example <caption>Use combineLatest with ES6 Promise</caption>\n * Rx.Observable.combineLatest(Promise.resolve(5), Promise.resolve(10), Promise.resolve(15))\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n * // Logs\n * // [5, 10, 15]\n * // \"the end!\"\n *\n *\n * @interface\n * @name SubscribableOrPromise\n * @noimport true\n ",
            "range": [
              7458,
              10776
            ],
            "loc": {
              "start": {
                "line": 195,
                "column": 0
              },
              "end": {
                "line": 280,
                "column": 3
              }
            }
          }
        ],
        "trailingComments": [
          {
            "type": "Block",
            "value": "*\n * `ObservableInput` interface describes all values that are either an\n * {@link SubscribableOrPromise} or some kind of collection of values that\n * can be transformed to Observable emitting that values. Every operator that\n * accepts arguments annotated with this interface, can be also used with\n * parameters that are not necessarily RxJS Observables.\n *\n * `ObservableInput` extends {@link SubscribableOrPromise} with following types:\n *\n * ## Array\n *\n * Arrays can be interpreted as observables that emit all values in array one by one,\n * from left to right, and then complete immediately.\n *\n * ## Array-like\n *\n * Arrays passed to operators do not have to be built-in JavaScript Arrays. They\n * can be also, for example, `arguments` property available inside every function,\n * [DOM NodeList](https://developer.mozilla.org/pl/docs/Web/API/NodeList),\n * or, actually, any object that has `length` property (which is a number)\n * and stores values under non-negative (zero and up) integers.\n *\n * ## ES6 Iterable\n *\n * Operators will accept both built-in and custom ES6 Iterables, by treating them as\n * observables that emit all its values in order of iteration and then complete\n * when iteration ends. Note that contrary to arrays, Iterables do not have to\n * necessarily be finite, so creating Observables that never complete is possible as well.\n *\n * Note that you can make iterator an instance of Iterable by having it return itself\n * in `Symbol.iterator` method. It means that every operator accepting Iterables accepts,\n * though indirectly, iterators themselves as well. All native ES6 iterators are instances\n * of Iterable by default, so you do not have to implement their `Symbol.iterator` method\n * yourself.\n *\n * **TypeScript Iterable interface issue**\n *\n * TypeScript `ObservableInput` interface actually lacks type signature for Iterables,\n * because of issues it caused in some projects (see [this issue](https://github.com/ReactiveX/rxjs/issues/2306)).\n * If you want to use Iterable as argument for operator, cast it to `any` first.\n * Remember of course that, because of casting, you have to yourself ensure that passed\n * argument really implements said interface.\n *\n *\n * @example <caption>Use merge with arrays</caption>\n * Rx.Observable.merge([1, 2], [4], [5, 6])\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * // \"ta dam!\"\n *\n *\n * @example <caption>Use merge with array-like</caption>\n * Rx.Observable.merge({0: 1, 1: 2, length: 2}, {0: 3, length: 1})\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('nice, huh?')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // \"nice, huh?\"\n *\n * @example <caption>Use merge with an Iterable (Map)</caption>\n * const firstMap = new Map([[1, 'a'], [2, 'b']]);\n * const secondMap = new Map([[3, 'c'], [4, 'd']]);\n *\n * Rx.Observable.merge(\n *   firstMap,          // pass Iterable\n *   secondMap.values() // pass iterator, which is itself an Iterable\n * ).subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('yup!')\n * );\n *\n * // Logs\n * // [1, \"a\"]\n * // [2, \"b\"]\n * // \"c\"\n * // \"d\"\n * // \"yup!\"\n *\n * @example <caption>Use from with generator (returning infinite iterator)</caption>\n * // infinite stream of incrementing numbers\n * const infinite = function* () {\n *   let i = 0;\n *\n *   while (true) {\n *     yield i++;\n *   }\n * };\n *\n * Rx.Observable.from(infinite())\n * .take(3) // only take 3, cause this is infinite\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 0\n * // 1\n * // 2\n * // \"ta dam!\"\n *\n * @interface\n * @name ObservableInput\n * @noimport true\n ",
            "range": [
              10819,
              14638
            ],
            "loc": {
              "start": {
                "line": 283,
                "column": 0
              },
              "end": {
                "line": 406,
                "column": 3
              }
            }
          }
        ]
      },
      "specifiers": [],
      "source": null,
      "range": [
        10777,
        10818
      ],
      "loc": {
        "start": {
          "line": 281,
          "column": 0
        },
        "end": {
          "line": 282,
          "column": 1
        }
      },
      "leadingComments": [
        {
          "type": "Block",
          "value": "*\n * `SubscribableOrPromise` interface describes values that behave like either\n * Observables or Promises. Every operator that accepts arguments annotated\n * with this interface, can be also used with parameters that are not necessarily\n * RxJS Observables.\n *\n * Following types of values might be passed to operators expecting this interface:\n *\n * ## Observable\n *\n * RxJS {@link Observable} instance.\n *\n * ## Observable-like (Subscribable)\n *\n * This might be any object that has `Symbol.observable` method. This method,\n * when called, should return object with `subscribe` method on it, which should\n * behave the same as RxJS `Observable.subscribe`.\n *\n * `Symbol.observable` is part of https://github.com/tc39/proposal-observable proposal.\n * Since currently it is not supported natively, and every symbol is equal only to itself,\n * you should use https://github.com/blesh/symbol-observable polyfill, when implementing\n * custom Observable-likes.\n *\n * **TypeScript Subscribable interface issue**\n *\n * Although TypeScript interface claims that Subscribable is an object that has `subscribe`\n * method declared directly on it, passing custom objects that have `subscribe`\n * method but not `Symbol.observable` method will fail at runtime. Conversely, passing\n * objects with `Symbol.observable` but without `subscribe` will fail at compile time\n * (if you use TypeScript).\n *\n * TypeScript has problem supporting interfaces with methods defined as symbol\n * properties. To get around that, you should implement `subscribe` directly on\n * passed object, and make `Symbol.observable` method simply return `this`. That way\n * everything will work as expected, and compiler will not complain. If you really\n * do not want to put `subscribe` directly on your object, you will have to type cast\n * it to `any`, before passing it to an operator.\n *\n * When this issue is resolved, Subscribable interface will only permit Observable-like\n * objects with `Symbol.observable` defined, no matter if they themselves implement\n * `subscribe` method or not.\n *\n * ## ES6 Promise\n *\n * Promise can be interpreted as Observable that emits value and completes\n * when it is resolved or errors when it is rejected.\n *\n * ## Promise-like (Thenable)\n *\n * Promises passed to operators do not have to be native ES6 Promises.\n * They can be implementations from popular Promise libraries, polyfills\n * or even custom ones. They just need to have `then` method that works\n * as the same as ES6 Promise `then`.\n *\n * @example <caption>Use merge and then map with non-RxJS observable</caption>\n * const nonRxJSObservable = {\n *   subscribe(observer) {\n *     observer.next(1000);\n *     observer.complete();\n *   },\n *   [Symbol.observable]() {\n *     return this;\n *   }\n * };\n *\n * Rx.Observable.merge(nonRxJSObservable)\n * .map(value => \"This value is \" + value)\n * .subscribe(result => console.log(result)); // Logs \"This value is 1000\"\n *\n *\n * @example <caption>Use combineLatest with ES6 Promise</caption>\n * Rx.Observable.combineLatest(Promise.resolve(5), Promise.resolve(10), Promise.resolve(15))\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n * // Logs\n * // [5, 10, 15]\n * // \"the end!\"\n *\n *\n * @interface\n * @name SubscribableOrPromise\n * @noimport true\n ",
          "range": [
            7458,
            10776
          ],
          "loc": {
            "start": {
              "line": 195,
              "column": 0
            },
            "end": {
              "line": 280,
              "column": 3
            }
          }
        }
      ],
      "trailingComments": [
        {
          "type": "Block",
          "value": "*\n * `ObservableInput` interface describes all values that are either an\n * {@link SubscribableOrPromise} or some kind of collection of values that\n * can be transformed to Observable emitting that values. Every operator that\n * accepts arguments annotated with this interface, can be also used with\n * parameters that are not necessarily RxJS Observables.\n *\n * `ObservableInput` extends {@link SubscribableOrPromise} with following types:\n *\n * ## Array\n *\n * Arrays can be interpreted as observables that emit all values in array one by one,\n * from left to right, and then complete immediately.\n *\n * ## Array-like\n *\n * Arrays passed to operators do not have to be built-in JavaScript Arrays. They\n * can be also, for example, `arguments` property available inside every function,\n * [DOM NodeList](https://developer.mozilla.org/pl/docs/Web/API/NodeList),\n * or, actually, any object that has `length` property (which is a number)\n * and stores values under non-negative (zero and up) integers.\n *\n * ## ES6 Iterable\n *\n * Operators will accept both built-in and custom ES6 Iterables, by treating them as\n * observables that emit all its values in order of iteration and then complete\n * when iteration ends. Note that contrary to arrays, Iterables do not have to\n * necessarily be finite, so creating Observables that never complete is possible as well.\n *\n * Note that you can make iterator an instance of Iterable by having it return itself\n * in `Symbol.iterator` method. It means that every operator accepting Iterables accepts,\n * though indirectly, iterators themselves as well. All native ES6 iterators are instances\n * of Iterable by default, so you do not have to implement their `Symbol.iterator` method\n * yourself.\n *\n * **TypeScript Iterable interface issue**\n *\n * TypeScript `ObservableInput` interface actually lacks type signature for Iterables,\n * because of issues it caused in some projects (see [this issue](https://github.com/ReactiveX/rxjs/issues/2306)).\n * If you want to use Iterable as argument for operator, cast it to `any` first.\n * Remember of course that, because of casting, you have to yourself ensure that passed\n * argument really implements said interface.\n *\n *\n * @example <caption>Use merge with arrays</caption>\n * Rx.Observable.merge([1, 2], [4], [5, 6])\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * // \"ta dam!\"\n *\n *\n * @example <caption>Use merge with array-like</caption>\n * Rx.Observable.merge({0: 1, 1: 2, length: 2}, {0: 3, length: 1})\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('nice, huh?')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // \"nice, huh?\"\n *\n * @example <caption>Use merge with an Iterable (Map)</caption>\n * const firstMap = new Map([[1, 'a'], [2, 'b']]);\n * const secondMap = new Map([[3, 'c'], [4, 'd']]);\n *\n * Rx.Observable.merge(\n *   firstMap,          // pass Iterable\n *   secondMap.values() // pass iterator, which is itself an Iterable\n * ).subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('yup!')\n * );\n *\n * // Logs\n * // [1, \"a\"]\n * // [2, \"b\"]\n * // \"c\"\n * // \"d\"\n * // \"yup!\"\n *\n * @example <caption>Use from with generator (returning infinite iterator)</caption>\n * // infinite stream of incrementing numbers\n * const infinite = function* () {\n *   let i = 0;\n *\n *   while (true) {\n *     yield i++;\n *   }\n * };\n *\n * Rx.Observable.from(infinite())\n * .take(3) // only take 3, cause this is infinite\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 0\n * // 1\n * // 2\n * // \"ta dam!\"\n *\n * @interface\n * @name ObservableInput\n * @noimport true\n ",
          "range": [
            10819,
            14638
          ],
          "loc": {
            "start": {
              "line": 283,
              "column": 0
            },
            "end": {
              "line": 406,
              "column": 3
            }
          }
        }
      ]
    },
    {
      "type": "ExportNamedDeclaration",
      "declaration": {
        "type": "ClassDeclaration",
        "id": {
          "type": "Identifier",
          "name": "ObservableInputDoc",
          "range": [
            14652,
            14670
          ],
          "loc": {
            "start": {
              "line": 407,
              "column": 13
            },
            "end": {
              "line": 407,
              "column": 31
            }
          }
        },
        "superClass": null,
        "body": {
          "type": "ClassBody",
          "body": [],
          "range": [
            14671,
            14674
          ],
          "loc": {
            "start": {
              "line": 407,
              "column": 32
            },
            "end": {
              "line": 408,
              "column": 1
            }
          }
        },
        "range": [
          14646,
          14674
        ],
        "loc": {
          "start": {
            "line": 407,
            "column": 7
          },
          "end": {
            "line": 408,
            "column": 1
          }
        },
        "leadingComments": [
          {
            "type": "Block",
            "value": "*\n * `ObservableInput` interface describes all values that are either an\n * {@link SubscribableOrPromise} or some kind of collection of values that\n * can be transformed to Observable emitting that values. Every operator that\n * accepts arguments annotated with this interface, can be also used with\n * parameters that are not necessarily RxJS Observables.\n *\n * `ObservableInput` extends {@link SubscribableOrPromise} with following types:\n *\n * ## Array\n *\n * Arrays can be interpreted as observables that emit all values in array one by one,\n * from left to right, and then complete immediately.\n *\n * ## Array-like\n *\n * Arrays passed to operators do not have to be built-in JavaScript Arrays. They\n * can be also, for example, `arguments` property available inside every function,\n * [DOM NodeList](https://developer.mozilla.org/pl/docs/Web/API/NodeList),\n * or, actually, any object that has `length` property (which is a number)\n * and stores values under non-negative (zero and up) integers.\n *\n * ## ES6 Iterable\n *\n * Operators will accept both built-in and custom ES6 Iterables, by treating them as\n * observables that emit all its values in order of iteration and then complete\n * when iteration ends. Note that contrary to arrays, Iterables do not have to\n * necessarily be finite, so creating Observables that never complete is possible as well.\n *\n * Note that you can make iterator an instance of Iterable by having it return itself\n * in `Symbol.iterator` method. It means that every operator accepting Iterables accepts,\n * though indirectly, iterators themselves as well. All native ES6 iterators are instances\n * of Iterable by default, so you do not have to implement their `Symbol.iterator` method\n * yourself.\n *\n * **TypeScript Iterable interface issue**\n *\n * TypeScript `ObservableInput` interface actually lacks type signature for Iterables,\n * because of issues it caused in some projects (see [this issue](https://github.com/ReactiveX/rxjs/issues/2306)).\n * If you want to use Iterable as argument for operator, cast it to `any` first.\n * Remember of course that, because of casting, you have to yourself ensure that passed\n * argument really implements said interface.\n *\n *\n * @example <caption>Use merge with arrays</caption>\n * Rx.Observable.merge([1, 2], [4], [5, 6])\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * // \"ta dam!\"\n *\n *\n * @example <caption>Use merge with array-like</caption>\n * Rx.Observable.merge({0: 1, 1: 2, length: 2}, {0: 3, length: 1})\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('nice, huh?')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // \"nice, huh?\"\n *\n * @example <caption>Use merge with an Iterable (Map)</caption>\n * const firstMap = new Map([[1, 'a'], [2, 'b']]);\n * const secondMap = new Map([[3, 'c'], [4, 'd']]);\n *\n * Rx.Observable.merge(\n *   firstMap,          // pass Iterable\n *   secondMap.values() // pass iterator, which is itself an Iterable\n * ).subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('yup!')\n * );\n *\n * // Logs\n * // [1, \"a\"]\n * // [2, \"b\"]\n * // \"c\"\n * // \"d\"\n * // \"yup!\"\n *\n * @example <caption>Use from with generator (returning infinite iterator)</caption>\n * // infinite stream of incrementing numbers\n * const infinite = function* () {\n *   let i = 0;\n *\n *   while (true) {\n *     yield i++;\n *   }\n * };\n *\n * Rx.Observable.from(infinite())\n * .take(3) // only take 3, cause this is infinite\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 0\n * // 1\n * // 2\n * // \"ta dam!\"\n *\n * @interface\n * @name ObservableInput\n * @noimport true\n ",
            "range": [
              10819,
              14638
            ],
            "loc": {
              "start": {
                "line": 283,
                "column": 0
              },
              "end": {
                "line": 406,
                "column": 3
              }
            }
          }
        ],
        "trailingComments": [
          {
            "type": "Block",
            "value": "*\n *\n * This interface describes what should be returned by function passed to Observable\n * constructor or static {@link create} function. Value of that interface will be used\n * to cancel subscription for given Observable.\n *\n * `TeardownLogic` can be:\n *\n * ## Function\n *\n * Function that takes no parameters. When consumer of created Observable calls `unsubscribe`,\n * that function will be called\n *\n * ## AnonymousSubscription\n *\n * `AnonymousSubscription` is simply an object with `unsubscribe` method on it. That method\n * will work the same as function\n *\n * ## void\n *\n * If created Observable does not have any resources to clean up, function does not have to\n * return anything.\n *\n * @interface\n * @name TeardownLogic\n * @noimport true\n ",
            "range": [
              14675,
              15430
            ],
            "loc": {
              "start": {
                "line": 409,
                "column": 0
              },
              "end": {
                "line": 435,
                "column": 3
              }
            }
          }
        ]
      },
      "specifiers": [],
      "source": null,
      "range": [
        14639,
        14674
      ],
      "loc": {
        "start": {
          "line": 407,
          "column": 0
        },
        "end": {
          "line": 408,
          "column": 1
        }
      },
      "leadingComments": [
        {
          "type": "Block",
          "value": "*\n * `ObservableInput` interface describes all values that are either an\n * {@link SubscribableOrPromise} or some kind of collection of values that\n * can be transformed to Observable emitting that values. Every operator that\n * accepts arguments annotated with this interface, can be also used with\n * parameters that are not necessarily RxJS Observables.\n *\n * `ObservableInput` extends {@link SubscribableOrPromise} with following types:\n *\n * ## Array\n *\n * Arrays can be interpreted as observables that emit all values in array one by one,\n * from left to right, and then complete immediately.\n *\n * ## Array-like\n *\n * Arrays passed to operators do not have to be built-in JavaScript Arrays. They\n * can be also, for example, `arguments` property available inside every function,\n * [DOM NodeList](https://developer.mozilla.org/pl/docs/Web/API/NodeList),\n * or, actually, any object that has `length` property (which is a number)\n * and stores values under non-negative (zero and up) integers.\n *\n * ## ES6 Iterable\n *\n * Operators will accept both built-in and custom ES6 Iterables, by treating them as\n * observables that emit all its values in order of iteration and then complete\n * when iteration ends. Note that contrary to arrays, Iterables do not have to\n * necessarily be finite, so creating Observables that never complete is possible as well.\n *\n * Note that you can make iterator an instance of Iterable by having it return itself\n * in `Symbol.iterator` method. It means that every operator accepting Iterables accepts,\n * though indirectly, iterators themselves as well. All native ES6 iterators are instances\n * of Iterable by default, so you do not have to implement their `Symbol.iterator` method\n * yourself.\n *\n * **TypeScript Iterable interface issue**\n *\n * TypeScript `ObservableInput` interface actually lacks type signature for Iterables,\n * because of issues it caused in some projects (see [this issue](https://github.com/ReactiveX/rxjs/issues/2306)).\n * If you want to use Iterable as argument for operator, cast it to `any` first.\n * Remember of course that, because of casting, you have to yourself ensure that passed\n * argument really implements said interface.\n *\n *\n * @example <caption>Use merge with arrays</caption>\n * Rx.Observable.merge([1, 2], [4], [5, 6])\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * // \"ta dam!\"\n *\n *\n * @example <caption>Use merge with array-like</caption>\n * Rx.Observable.merge({0: 1, 1: 2, length: 2}, {0: 3, length: 1})\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('nice, huh?')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // \"nice, huh?\"\n *\n * @example <caption>Use merge with an Iterable (Map)</caption>\n * const firstMap = new Map([[1, 'a'], [2, 'b']]);\n * const secondMap = new Map([[3, 'c'], [4, 'd']]);\n *\n * Rx.Observable.merge(\n *   firstMap,          // pass Iterable\n *   secondMap.values() // pass iterator, which is itself an Iterable\n * ).subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('yup!')\n * );\n *\n * // Logs\n * // [1, \"a\"]\n * // [2, \"b\"]\n * // \"c\"\n * // \"d\"\n * // \"yup!\"\n *\n * @example <caption>Use from with generator (returning infinite iterator)</caption>\n * // infinite stream of incrementing numbers\n * const infinite = function* () {\n *   let i = 0;\n *\n *   while (true) {\n *     yield i++;\n *   }\n * };\n *\n * Rx.Observable.from(infinite())\n * .take(3) // only take 3, cause this is infinite\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 0\n * // 1\n * // 2\n * // \"ta dam!\"\n *\n * @interface\n * @name ObservableInput\n * @noimport true\n ",
          "range": [
            10819,
            14638
          ],
          "loc": {
            "start": {
              "line": 283,
              "column": 0
            },
            "end": {
              "line": 406,
              "column": 3
            }
          }
        }
      ],
      "trailingComments": [
        {
          "type": "Block",
          "value": "*\n *\n * This interface describes what should be returned by function passed to Observable\n * constructor or static {@link create} function. Value of that interface will be used\n * to cancel subscription for given Observable.\n *\n * `TeardownLogic` can be:\n *\n * ## Function\n *\n * Function that takes no parameters. When consumer of created Observable calls `unsubscribe`,\n * that function will be called\n *\n * ## AnonymousSubscription\n *\n * `AnonymousSubscription` is simply an object with `unsubscribe` method on it. That method\n * will work the same as function\n *\n * ## void\n *\n * If created Observable does not have any resources to clean up, function does not have to\n * return anything.\n *\n * @interface\n * @name TeardownLogic\n * @noimport true\n ",
          "range": [
            14675,
            15430
          ],
          "loc": {
            "start": {
              "line": 409,
              "column": 0
            },
            "end": {
              "line": 435,
              "column": 3
            }
          }
        }
      ]
    },
    {
      "type": "ExportNamedDeclaration",
      "declaration": {
        "type": "ClassDeclaration",
        "id": {
          "type": "Identifier",
          "name": "TeardownLogicDoc",
          "range": [
            15444,
            15460
          ],
          "loc": {
            "start": {
              "line": 436,
              "column": 13
            },
            "end": {
              "line": 436,
              "column": 29
            }
          }
        },
        "superClass": null,
        "body": {
          "type": "ClassBody",
          "body": [],
          "range": [
            15461,
            15464
          ],
          "loc": {
            "start": {
              "line": 436,
              "column": 30
            },
            "end": {
              "line": 437,
              "column": 1
            }
          }
        },
        "range": [
          15438,
          15464
        ],
        "loc": {
          "start": {
            "line": 436,
            "column": 7
          },
          "end": {
            "line": 437,
            "column": 1
          }
        },
        "leadingComments": [
          {
            "type": "Block",
            "value": "*\n *\n * This interface describes what should be returned by function passed to Observable\n * constructor or static {@link create} function. Value of that interface will be used\n * to cancel subscription for given Observable.\n *\n * `TeardownLogic` can be:\n *\n * ## Function\n *\n * Function that takes no parameters. When consumer of created Observable calls `unsubscribe`,\n * that function will be called\n *\n * ## AnonymousSubscription\n *\n * `AnonymousSubscription` is simply an object with `unsubscribe` method on it. That method\n * will work the same as function\n *\n * ## void\n *\n * If created Observable does not have any resources to clean up, function does not have to\n * return anything.\n *\n * @interface\n * @name TeardownLogic\n * @noimport true\n ",
            "range": [
              14675,
              15430
            ],
            "loc": {
              "start": {
                "line": 409,
                "column": 0
              },
              "end": {
                "line": 435,
                "column": 3
              }
            }
          }
        ],
        "trailingComments": [
          {
            "type": "Line",
            "value": "# sourceMappingURL=MiscJSDoc.js.map",
            "range": [
              15465,
              15502
            ],
            "loc": {
              "start": {
                "line": 438,
                "column": 0
              },
              "end": {
                "line": 438,
                "column": 37
              }
            }
          }
        ]
      },
      "specifiers": [],
      "source": null,
      "range": [
        15431,
        15464
      ],
      "loc": {
        "start": {
          "line": 436,
          "column": 0
        },
        "end": {
          "line": 437,
          "column": 1
        }
      },
      "leadingComments": [
        {
          "type": "Block",
          "value": "*\n *\n * This interface describes what should be returned by function passed to Observable\n * constructor or static {@link create} function. Value of that interface will be used\n * to cancel subscription for given Observable.\n *\n * `TeardownLogic` can be:\n *\n * ## Function\n *\n * Function that takes no parameters. When consumer of created Observable calls `unsubscribe`,\n * that function will be called\n *\n * ## AnonymousSubscription\n *\n * `AnonymousSubscription` is simply an object with `unsubscribe` method on it. That method\n * will work the same as function\n *\n * ## void\n *\n * If created Observable does not have any resources to clean up, function does not have to\n * return anything.\n *\n * @interface\n * @name TeardownLogic\n * @noimport true\n ",
          "range": [
            14675,
            15430
          ],
          "loc": {
            "start": {
              "line": 409,
              "column": 0
            },
            "end": {
              "line": 435,
              "column": 3
            }
          }
        }
      ],
      "trailingComments": [
        {
          "type": "Line",
          "value": "# sourceMappingURL=MiscJSDoc.js.map",
          "range": [
            15465,
            15502
          ],
          "loc": {
            "start": {
              "line": 438,
              "column": 0
            },
            "end": {
              "line": 438,
              "column": 37
            }
          }
        }
      ]
    }
  ],
  "sourceType": "module",
  "range": [
    0,
    15464
  ],
  "loc": {
    "start": {
      "line": 1,
      "column": 0
    },
    "end": {
      "line": 437,
      "column": 1
    }
  },
  "comments": [
    {
      "type": "Block",
      "value": "*\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n ",
      "range": [
        80,
        174
      ],
      "loc": {
        "start": {
          "line": 3,
          "column": 0
        },
        "end": {
          "line": 7,
          "column": 3
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n     * Creates a new Observable, that will execute the specified function when an\n     * {@link Observer} subscribes to it.\n     *\n     * <span class=\"informal\">Create custom Observable, that does whatever you like.</span>\n     *\n     * <img src=\"./img/create.png\" width=\"100%\">\n     *\n     * `create` converts an `onSubscription` function to an actual Observable.\n     * Whenever someone subscribes to that Observable, the function will be called\n     * with an {@link Observer} instance as a first and only parameter. `onSubscription` should\n     * then invoke the Observers `next`, `error` and `complete` methods.\n     *\n     * Calling `next` with a value will emit that value to the observer. Calling `complete`\n     * means that Observable finished emitting and will not do anything else.\n     * Calling `error` means that something went wrong - value passed to `error` method should\n     * provide details on what exactly happened.\n     *\n     * A well-formed Observable can emit as many values as it needs via `next` method,\n     * but `complete` and `error` methods can be called only once and nothing else can be called\n     * thereafter. If you try to invoke `next`, `complete` or `error` methods after created\n     * Observable already completed or ended with an error, these calls will be ignored to\n     * preserve so called *Observable Contract*. Note that you are not required to call\n     * `complete` at any point - it is perfectly fine to create an Observable that never ends,\n     * depending on your needs.\n     *\n     * `onSubscription` can optionally return either a function or an object with\n     * `unsubscribe` method. In both cases function or method will be called when\n     * subscription to Observable is being cancelled and should be used to clean up all\n     * resources. So, for example, if you are using `setTimeout` in your custom\n     * Observable, when someone unsubscribes, you can clear planned timeout, so that\n     * it does not fire needlessly and browser (or other environment) does not waste\n     * computing power on timing event that no one will listen to anyways.\n     *\n     * Most of the times you should not need to use `create`, because existing\n     * operators allow you to create an Observable for most of the use cases.\n     * That being said, `create` is low-level mechanism allowing you to create\n     * any Observable, if you have very specific needs.\n     *\n     * **TypeScript signature issue**\n     *\n     * Because Observable extends class which already has defined static `create` function,\n     * but with different type signature, it was impossible to assign proper signature to\n     * `Observable.create`. Because of that, it has very general type `Function` and thus\n     * function passed to `create` will not be type checked, unless you explicitly state\n     * what signature it should have.\n     *\n     * When using TypeScript we recommend to declare type signature of function passed to\n     * `create` as `(observer: Observer) => TeardownLogic`, where {@link Observer}\n     * and {@link TeardownLogic} are interfaces provided by the library.\n     *\n     * @example <caption>Emit three numbers, then complete.</caption>\n     * var observable = Rx.Observable.create(function (observer) {\n     *   observer.next(1);\n     *   observer.next(2);\n     *   observer.next(3);\n     *   observer.complete();\n     * });\n     * observable.subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('this is the end')\n     * );\n     *\n     * // Logs\n     * // 1\n     * // 2\n     * // 3\n     * // \"this is the end\"\n     *\n     *\n     * @example <caption>Emit an error</caption>\n     * const observable = Rx.Observable.create((observer) => {\n     *   observer.error('something went really wrong...');\n     * });\n     *\n     * observable.subscribe(\n     *   value => console.log(value), // will never be called\n     *   err => console.log(err),\n     *   () => console.log('complete') // will never be called\n     * );\n     *\n     * // Logs\n     * // \"something went really wrong...\"\n     *\n     *\n     * @example <caption>Return unsubscribe function</caption>\n     *\n     * const observable = Rx.Observable.create(observer => {\n     *   const id = setTimeout(() => observer.next('...'), 5000); // emit value after 5s\n     *\n     *   return () => { clearTimeout(id); console.log('cleared!'); };\n     * });\n     *\n     * const subscription = observable.subscribe(value => console.log(value));\n     *\n     * setTimeout(() => subscription.unsubscribe(), 3000); // cancel subscription after 3s\n     *\n     * // Logs:\n     * // \"cleared!\" after 3s\n     *\n     * // Never logs \"...\"\n     *\n     *\n     * @see {@link empty}\n     * @see {@link never}\n     * @see {@link of}\n     * @see {@link throw}\n     *\n     * @param {function(observer: Observer): TeardownLogic} onSubscription A\n     * function that accepts an Observer, and invokes its `next`,\n     * `error`, and `complete` methods as appropriate, and optionally returns some\n     * logic for cleaning up resources.\n     * @return {Observable} An Observable that, whenever subscribed, will execute the\n     * specified function.\n     * @static true\n     * @name create\n     * @owner Observable\n     ",
      "range": [
        208,
        5453
      ],
      "loc": {
        "start": {
          "line": 9,
          "column": 4
        },
        "end": {
          "line": 127,
          "column": 7
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n * An interface for a consumer of push-based notifications delivered by an\n * {@link Observable}.\n *\n * ```ts\n * interface Observer<T> {\n *   closed?: boolean;\n *   next: (value: T) => void;\n *   error: (err: any) => void;\n *   complete: () => void;\n * }\n * ```\n *\n * An object conforming to the Observer interface is usually\n * given to the `observable.subscribe(observer)` method, and the Observable will\n * call the Observer's `next(value)` method to provide notifications. A\n * well-behaved Observable will call an Observer's `complete()` method exactly\n * once or the Observer's `error(err)` method exactly once, as the last\n * notification delivered.\n *\n * @interface\n * @name Observer\n * @noimport true\n ",
      "range": [
        5551,
        6268
      ],
      "loc": {
        "start": {
          "line": 133,
          "column": 0
        },
        "end": {
          "line": 156,
          "column": 3
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n         * An optional flag to indicate whether this Observer, when used as a\n         * subscriber, has already been unsubscribed from its Observable.\n         * @type {boolean}\n         ",
      "range": [
        6324,
        6518
      ],
      "loc": {
        "start": {
          "line": 159,
          "column": 8
        },
        "end": {
          "line": 163,
          "column": 11
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n     * The callback to receive notifications of type `next` from the Observable,\n     * with a value. The Observable may call this method 0 or more times.\n     * @param {T} value The `next` value.\n     * @return {void}\n     ",
      "range": [
        6558,
        6788
      ],
      "loc": {
        "start": {
          "line": 166,
          "column": 4
        },
        "end": {
          "line": 171,
          "column": 7
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n     * The callback to receive notifications of type `error` from the Observable,\n     * with an attached {@link Error}. Notifies the Observer that the Observable\n     * has experienced an error condition.\n     * @param {any} err The `error` exception.\n     * @return {void}\n     ",
      "range": [
        6840,
        7126
      ],
      "loc": {
        "start": {
          "line": 175,
          "column": 4
        },
        "end": {
          "line": 181,
          "column": 7
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n     * The callback to receive a valueless notification of type `complete` from\n     * the Observable. Notifies the Observer that the Observable has finished\n     * sending push-based notifications.\n     * @return {void}\n     ",
      "range": [
        7177,
        7409
      ],
      "loc": {
        "start": {
          "line": 185,
          "column": 4
        },
        "end": {
          "line": 190,
          "column": 7
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n * `SubscribableOrPromise` interface describes values that behave like either\n * Observables or Promises. Every operator that accepts arguments annotated\n * with this interface, can be also used with parameters that are not necessarily\n * RxJS Observables.\n *\n * Following types of values might be passed to operators expecting this interface:\n *\n * ## Observable\n *\n * RxJS {@link Observable} instance.\n *\n * ## Observable-like (Subscribable)\n *\n * This might be any object that has `Symbol.observable` method. This method,\n * when called, should return object with `subscribe` method on it, which should\n * behave the same as RxJS `Observable.subscribe`.\n *\n * `Symbol.observable` is part of https://github.com/tc39/proposal-observable proposal.\n * Since currently it is not supported natively, and every symbol is equal only to itself,\n * you should use https://github.com/blesh/symbol-observable polyfill, when implementing\n * custom Observable-likes.\n *\n * **TypeScript Subscribable interface issue**\n *\n * Although TypeScript interface claims that Subscribable is an object that has `subscribe`\n * method declared directly on it, passing custom objects that have `subscribe`\n * method but not `Symbol.observable` method will fail at runtime. Conversely, passing\n * objects with `Symbol.observable` but without `subscribe` will fail at compile time\n * (if you use TypeScript).\n *\n * TypeScript has problem supporting interfaces with methods defined as symbol\n * properties. To get around that, you should implement `subscribe` directly on\n * passed object, and make `Symbol.observable` method simply return `this`. That way\n * everything will work as expected, and compiler will not complain. If you really\n * do not want to put `subscribe` directly on your object, you will have to type cast\n * it to `any`, before passing it to an operator.\n *\n * When this issue is resolved, Subscribable interface will only permit Observable-like\n * objects with `Symbol.observable` defined, no matter if they themselves implement\n * `subscribe` method or not.\n *\n * ## ES6 Promise\n *\n * Promise can be interpreted as Observable that emits value and completes\n * when it is resolved or errors when it is rejected.\n *\n * ## Promise-like (Thenable)\n *\n * Promises passed to operators do not have to be native ES6 Promises.\n * They can be implementations from popular Promise libraries, polyfills\n * or even custom ones. They just need to have `then` method that works\n * as the same as ES6 Promise `then`.\n *\n * @example <caption>Use merge and then map with non-RxJS observable</caption>\n * const nonRxJSObservable = {\n *   subscribe(observer) {\n *     observer.next(1000);\n *     observer.complete();\n *   },\n *   [Symbol.observable]() {\n *     return this;\n *   }\n * };\n *\n * Rx.Observable.merge(nonRxJSObservable)\n * .map(value => \"This value is \" + value)\n * .subscribe(result => console.log(result)); // Logs \"This value is 1000\"\n *\n *\n * @example <caption>Use combineLatest with ES6 Promise</caption>\n * Rx.Observable.combineLatest(Promise.resolve(5), Promise.resolve(10), Promise.resolve(15))\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('the end!')\n * );\n * // Logs\n * // [5, 10, 15]\n * // \"the end!\"\n *\n *\n * @interface\n * @name SubscribableOrPromise\n * @noimport true\n ",
      "range": [
        7458,
        10776
      ],
      "loc": {
        "start": {
          "line": 195,
          "column": 0
        },
        "end": {
          "line": 280,
          "column": 3
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n * `ObservableInput` interface describes all values that are either an\n * {@link SubscribableOrPromise} or some kind of collection of values that\n * can be transformed to Observable emitting that values. Every operator that\n * accepts arguments annotated with this interface, can be also used with\n * parameters that are not necessarily RxJS Observables.\n *\n * `ObservableInput` extends {@link SubscribableOrPromise} with following types:\n *\n * ## Array\n *\n * Arrays can be interpreted as observables that emit all values in array one by one,\n * from left to right, and then complete immediately.\n *\n * ## Array-like\n *\n * Arrays passed to operators do not have to be built-in JavaScript Arrays. They\n * can be also, for example, `arguments` property available inside every function,\n * [DOM NodeList](https://developer.mozilla.org/pl/docs/Web/API/NodeList),\n * or, actually, any object that has `length` property (which is a number)\n * and stores values under non-negative (zero and up) integers.\n *\n * ## ES6 Iterable\n *\n * Operators will accept both built-in and custom ES6 Iterables, by treating them as\n * observables that emit all its values in order of iteration and then complete\n * when iteration ends. Note that contrary to arrays, Iterables do not have to\n * necessarily be finite, so creating Observables that never complete is possible as well.\n *\n * Note that you can make iterator an instance of Iterable by having it return itself\n * in `Symbol.iterator` method. It means that every operator accepting Iterables accepts,\n * though indirectly, iterators themselves as well. All native ES6 iterators are instances\n * of Iterable by default, so you do not have to implement their `Symbol.iterator` method\n * yourself.\n *\n * **TypeScript Iterable interface issue**\n *\n * TypeScript `ObservableInput` interface actually lacks type signature for Iterables,\n * because of issues it caused in some projects (see [this issue](https://github.com/ReactiveX/rxjs/issues/2306)).\n * If you want to use Iterable as argument for operator, cast it to `any` first.\n * Remember of course that, because of casting, you have to yourself ensure that passed\n * argument really implements said interface.\n *\n *\n * @example <caption>Use merge with arrays</caption>\n * Rx.Observable.merge([1, 2], [4], [5, 6])\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * // \"ta dam!\"\n *\n *\n * @example <caption>Use merge with array-like</caption>\n * Rx.Observable.merge({0: 1, 1: 2, length: 2}, {0: 3, length: 1})\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('nice, huh?')\n * );\n *\n * // Logs\n * // 1\n * // 2\n * // 3\n * // \"nice, huh?\"\n *\n * @example <caption>Use merge with an Iterable (Map)</caption>\n * const firstMap = new Map([[1, 'a'], [2, 'b']]);\n * const secondMap = new Map([[3, 'c'], [4, 'd']]);\n *\n * Rx.Observable.merge(\n *   firstMap,          // pass Iterable\n *   secondMap.values() // pass iterator, which is itself an Iterable\n * ).subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('yup!')\n * );\n *\n * // Logs\n * // [1, \"a\"]\n * // [2, \"b\"]\n * // \"c\"\n * // \"d\"\n * // \"yup!\"\n *\n * @example <caption>Use from with generator (returning infinite iterator)</caption>\n * // infinite stream of incrementing numbers\n * const infinite = function* () {\n *   let i = 0;\n *\n *   while (true) {\n *     yield i++;\n *   }\n * };\n *\n * Rx.Observable.from(infinite())\n * .take(3) // only take 3, cause this is infinite\n * .subscribe(\n *   value => console.log(value),\n *   err => {},\n *   () => console.log('ta dam!')\n * );\n *\n * // Logs\n * // 0\n * // 1\n * // 2\n * // \"ta dam!\"\n *\n * @interface\n * @name ObservableInput\n * @noimport true\n ",
      "range": [
        10819,
        14638
      ],
      "loc": {
        "start": {
          "line": 283,
          "column": 0
        },
        "end": {
          "line": 406,
          "column": 3
        }
      }
    },
    {
      "type": "Block",
      "value": "*\n *\n * This interface describes what should be returned by function passed to Observable\n * constructor or static {@link create} function. Value of that interface will be used\n * to cancel subscription for given Observable.\n *\n * `TeardownLogic` can be:\n *\n * ## Function\n *\n * Function that takes no parameters. When consumer of created Observable calls `unsubscribe`,\n * that function will be called\n *\n * ## AnonymousSubscription\n *\n * `AnonymousSubscription` is simply an object with `unsubscribe` method on it. That method\n * will work the same as function\n *\n * ## void\n *\n * If created Observable does not have any resources to clean up, function does not have to\n * return anything.\n *\n * @interface\n * @name TeardownLogic\n * @noimport true\n ",
      "range": [
        14675,
        15430
      ],
      "loc": {
        "start": {
          "line": 409,
          "column": 0
        },
        "end": {
          "line": 435,
          "column": 3
        }
      }
    },
    {
      "type": "Line",
      "value": "# sourceMappingURL=MiscJSDoc.js.map",
      "range": [
        15465,
        15502
      ],
      "loc": {
        "start": {
          "line": 438,
          "column": 0
        },
        "end": {
          "line": 438,
          "column": 37
        }
      }
    }
  ]
}